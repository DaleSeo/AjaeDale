---
import Layout from "../../layouts/Layout.astro";
import SearchIcon from "../../icons/Search.astro";
import XIcon from "../../icons/X.astro";
import {
  useTranslations,
  getStaticPathsLocales,
  normalizeLang,
} from "../../i18n/utils";

export async function getStaticPaths() {
  return getStaticPathsLocales().map((lang) => ({
    params: { lang },
  }));
}

const { lang: langParam } = Astro.params;
const lang = normalizeLang(langParam);
const t = useTranslations(lang);

// í˜ì´ì§€ ë©”íƒ€ ì •ë³´
const title = t("search.title");
const description = t("search.description");
---

<Layout
  title={title}
  description={description}
  currentPage="search"
  lang={lang}
>
  <!-- í—¤ë” ì„¹ì…˜ -->
  <section
    class="from-primary/5 to-background bg-gradient-to-b px-4 py-12"
    data-pagefind-ignore
  >
    <div class="container mx-auto max-w-4xl text-center">
      <h1 class="text-foreground mb-3 text-3xl font-bold md:text-4xl">
        ğŸ” {title}
      </h1>
      <p class="text-muted-foreground text-lg">{description}</p>
    </div>
  </section>

  <!-- ê²€ìƒ‰ ì„¹ì…˜ -->
  <section class="px-4 py-8" data-pagefind-ignore>
    <div class="container mx-auto max-w-4xl">
      <!-- ê²€ìƒ‰ ì…ë ¥ -->
      <div class="mb-8">
        <div class="relative">
          <div
            class="pointer-events-none absolute inset-y-0 left-0 flex items-center pl-4"
          >
            <SearchIcon size={20} class="text-muted-foreground" />
          </div>
          <input
            type="text"
            id="search-input"
            class="bg-card border-border focus:ring-primary focus:border-primary text-foreground placeholder-muted-foreground w-full rounded-xl border-2 py-4 pr-12 pl-12 text-lg transition-all focus:ring-2 focus:outline-none"
            placeholder={t("search.placeholder")}
            autofocus
          />
          <button
            id="clear-button"
            class="text-muted-foreground hover:text-foreground absolute inset-y-0 right-0 flex hidden items-center pr-4 transition-colors"
            aria-label={t("search.clearButton")}
          >
            <XIcon size={20} />
          </button>
        </div>
        <p class="text-muted-foreground mt-2 ml-1 text-sm">
          {t("search.hint")}
        </p>
      </div>

      <!-- ê²€ìƒ‰ ê²°ê³¼ -->
      <div id="search-results" class="space-y-4"></div>

      <!-- ê²€ìƒ‰ ê²°ê³¼ ì—†ìŒ -->
      <div
        id="no-results"
        class="bg-card border-border hidden rounded-xl border py-12 text-center"
      >
        <div class="mb-4 text-4xl">ğŸ”</div>
        <p class="text-muted-foreground mb-2 text-xl">
          {t("search.noResults")}
        </p>
        <p class="text-muted-foreground text-sm">
          {t("search.tryAgain")}
        </p>
      </div>
    </div>
  </section>
</Layout>

<script>
  // Get current language from URL
  const currentPath = window.location.pathname;
  const currentLang = currentPath.startsWith("/en/") ? "en" : "ko";

  // URLì—ì„œ ê²€ìƒ‰ì–´ ê°€ì ¸ì˜¤ê¸°
  const urlParams = new URLSearchParams(window.location.search);
  const initialQuery = urlParams.get("q") || "";

  const searchInput = document.getElementById(
    "search-input",
  ) as HTMLInputElement;
  const searchResults = document.getElementById("search-results");
  const noResults = document.getElementById("no-results");
  const clearButton = document.getElementById("clear-button");

  let pagefind: any;

  // Pagefind ì´ˆê¸°í™”
  async function initPagefind() {
    try {
      // @ts-ignore - ë™ì  importë¥¼ ì‚¬ìš©í•˜ì—¬ Vite ë¶„ì„ ìš°íšŒ
      const pagefindPath = "/pagefind/pagefind.js";
      pagefind = await import(/* @vite-ignore */ pagefindPath);

      // Set language filter for multilingual search
      if (pagefind && currentLang) {
        await pagefind.options({
          filters: {
            lang: currentLang,
          },
        });
      }
    } catch (e) {
      console.error("Pagefind not available. Run 'bun run build' first.");
    }
  }

  // Clear ë²„íŠ¼ í‘œì‹œ/ìˆ¨ê¹€ ì—…ë°ì´íŠ¸
  function updateClearButton() {
    if (!clearButton) return;
    if (searchInput.value.trim()) {
      clearButton.classList.remove("hidden");
    } else {
      clearButton.classList.add("hidden");
    }
  }

  // ê²€ìƒ‰ ìˆ˜í–‰
  async function performSearch(query: string) {
    updateClearButton();

    if (!query.trim()) {
      if (searchResults) searchResults.innerHTML = "";
      if (noResults) noResults.classList.add("hidden");
      return;
    }

    // URL ì—…ë°ì´íŠ¸
    const newUrl = new URL(window.location.href);
    newUrl.searchParams.set("q", query);
    window.history.replaceState({}, "", newUrl);

    if (!pagefind) {
      await initPagefind();
    }

    const search = await pagefind.search(query);

    if (!searchResults || !noResults) return;

    if (search.results.length === 0) {
      searchResults.innerHTML = "";
      noResults.classList.remove("hidden");
      return;
    }

    noResults.classList.add("hidden");

    // ê²°ê³¼ ë Œë”ë§
    const resultsHTML = await Promise.all(
      search.results.map(async (result: any) => {
        const data = await result.data();

        // contentì—ì„œ ì‹¤ì œ ê°œê·¸ ì œëª© ì¶”ì¶œ (HTML íƒœê·¸ ì œê±°)
        const title = data.content || data.meta.title || "ì œëª© ì—†ìŒ";
        const cleanTitle = title.replace(/<[^>]*>/g, "").trim();

        // excerpt ì¶”ì¶œ (ìˆëŠ” ê²½ìš°)
        const excerpt = data.excerpt || "";
        const cleanExcerpt = excerpt.replace(/<[^>]*>/g, "").trim();

        return `
          <a href="${data.url}" class="block p-6 bg-card border border-border rounded-lg hover:border-primary/50 hover:shadow-md transition-all duration-200 group">
            <h3 class="text-lg font-semibold text-foreground mb-2 group-hover:text-primary transition-colors">
              ${cleanTitle}
            </h3>
            ${cleanExcerpt ? `<p class="text-sm text-muted-foreground line-clamp-2">${cleanExcerpt}</p>` : ""}
          </a>
        `;
      }),
    );

    searchResults.innerHTML = resultsHTML.join("");
  }

  // Debounce í•¨ìˆ˜
  function debounce(func: Function, wait: number) {
    let timeout: ReturnType<typeof setTimeout>;
    return function executedFunction(...args: any[]) {
      const later = () => {
        clearTimeout(timeout);
        func(...args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }

  // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
  if (searchInput) {
    // ì´ˆê¸° ê²€ìƒ‰ì–´ê°€ ìˆìœ¼ë©´ ê²€ìƒ‰ ìˆ˜í–‰
    if (initialQuery) {
      searchInput.value = initialQuery;
      performSearch(initialQuery);
    }

    const debouncedSearch = debounce((e: Event) => {
      const target = e.target as HTMLInputElement;
      performSearch(target.value);
    }, 300);

    searchInput.addEventListener("input", debouncedSearch);
  }

  // Clear ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸
  if (clearButton) {
    clearButton.addEventListener("click", () => {
      searchInput.value = "";
      searchInput.focus();
      performSearch("");
    });
  }

  // Pagefind ì´ˆê¸°í™”
  initPagefind();
</script>
